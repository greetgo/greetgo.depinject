### Ссылки

 - [Очень быстрый старт (через TestNG)](fast_start.md)
 - [Быстрый старт (main-функция или war-файл)](quick_start.md)
 - [Концепция]
 - [Спецификация](spec.md)

### Концепция

Если объектов в программе очень много и взаимоотношения между ними очень сложные, то код по их инициализации может
оказаться очень сложным. А ещё сложнее его поддерживать в адекватном состоянии. А ещё всё может усложниться тем,
что нужно иметь несколько вариантов инициализации объектов.

Было бы превосходно, если бы всю эту работу снять с программиста и передать компьютеру - чтобы он сам это всё делал,
а программист бы занимался только решением конкретной задачи. Программисту нужно сказать только то, что ему нужно в
том или ином месте, и "какая-то волшебная штука" ему это давала, притом сразу.

Для решения этой задачи был придуман паттерн Dependency Injection (Внедрение Зависимостей).
И depinject решает эту задачу.

Библиотека depinject работает со специальными объектами, которые называются бинами (Bean - боб). В бинах
описано, что ему нужно и библиотека это предоставляет.

> Ну а бинам, всегда нужны другие бины, и больше ничего

И это достаточно легко реализовать, что depinject и делает. Основной алгоритм работы depinject выглядить примерно так:

> Создаём бины с помощью аннотации `@Bean`. Но бины используются только те, которые подключены. Подключаем бины
  с помощью `@BeanConfig`, не забывая использовать `@BeanScanner`. Далее создаём `BeanContainer`, и, с помощью
  аннотации `@Include`, подключаем к нему созданные нами `@BeanConfig`-и. Далее из BeanContainer-а вытаскиваем
  нужные нам бины (которые уже корректно инициированны) и используем их.
  Бины внутри обращаются друг-к-другу посредством `BeanGetter`-а.

Используя depinject в сочетании с наследованием можно очень гибко настраивать внутреннюю инфраструктуру проекта. Так как
depinject создаёт инстанции бинов только по мере необходимости, то можно в бин-контэйнер ложить сотни тысяч бинов и
система будет запускаться ни чуть не медленнее, чем пять бинов.

В depinject-е даже загрузка класса бина происходит по требованию.

### Бины

> Бины - это объекты, которые автоматически созданны и инициированы нужными им связями на другие бины.

> Бин-классы - это классы, инстанции которых могут быть бинами. Т.е. бин - это инстанция бин-класса.

> Инстанции бин-классов создаются в бин-контэйнере по мере необходимости. 

Чтобы класс сделать бин-классом, его необходимо пометить аннотацией `@Bean`. Также у бин-класса должен быть публичный
контсруктор по умолчанию, иначе система не сможет создавать инстанции этого класса. Существует [всего три способа
создания бинов](#bean-creation-variants) (- см. ниже).

Аннотации `@Bean` не достаточно, чтобы можно было создавать бин. Бин-класс необходимо ещё подключить к бин-контэйнеру.

> Подключение бин-классов к бин-контэйнерам происходит с помощью бин-конфигов

### Бин конфиги

Бин-конфиг - это класс без методов и полей, ни что не наследующий и ни чего не расширяющий. Бин конфиг должен быть
помечен аннотацией `@BeanConfig` - так он отмечается, что это бин-конфиг.

Бин-конфиг должен содержать аннотации: `@BeanScanner`, `@Include` (одну из них или обе). 

Аннотация `@BeanScanner` обозначает, что данный бин-конфиг подключает все бин-классы, которые находятся в пакете данного
бин-конфига, а также во всей иерархии подпакетов этого пакета. (Этот конфиг как бы сканирует свой пакет и все
внутренние пакеты на наличие бинов).

Аннотация `@Include` подключает к данному бин-конфигу другие бин-конфиги, которые указанны в этой аннотации.

С помощью аннотаций `@BeanConfig`, `@BeanScanner` и `@Include` можно создавать разветвлённую сеть бинов, в нутри
проекта. Можно создать несколько бин-контэйнеров, и каждый бин-контэйнер содержит свой набор бинов. Какие-то бины
подключены к одному бин-контэйнеру, а какие-то к другом, а какие-то бины могут быть подключены
к нескольким бин-контэйнерам.

Таким простым способом можно настроить очень гибкую систему распределения бинов в проекте.
Какие-то бины могут быть только в продукте, какие-то только среди тестов, какие-то и там и там (например те, которых
надо тестировать).

### Точечное соединения бинов

Подключение одного бина к другому происходит с помощью интерфейса `BeanGetter`, например:

```
  public BeanGetter<SomeClass> someBean;
```

Сюда подключается бин, который должен быть `instanceOf SomeClass`. Такой бин должен найтись ровно один. Если их
найдётся больше или вообще ни одного не найдётся, то происходит ошибка сборки.

> Разработчик специально сделал так, чтобы в этом случае происходила ошибка. Чтобы небыло проблем с возвращением
  `null`; или проблем с непонятностью: а какой бин сюда подключиться. А с ошибкой всё понятно: конфигурируй так,
  чтобы был только один бин. И это на практике очень удобно.

### Множественное соединения бинов

Можно к одному бину за раз подключить сразу несколько бинов. Делается это с использованием `java.util.List`, например:

```
  public BeanGetter<List<SomeClass>> beans;
```

Сюда подключаются все бины, которые `instanceOf SomeClass`. Если таких бинов нет, то присвоится пустой массив.
Последовательность, в которой будут лежать бины внутри списка, **НЕ** определена, и возможности её задать нет.

### Синглтоны

Бин-классы могут быть синглтонами, а могут и не быть синглтонами. Если бин не
должен быть синглтоном, то его надо пометить так: `@Bean(singleton = false)`.

По умолчанию бин-класс - синглтон.

Синглтоны создаются и инициируются потокобезопасно.

Следует понимать, что синглтон в depinject-е содержит одну инстанцию в рамках инстанции бин-контэйнера. Если создать
ещё одну инстанцию бин-контэйнера, то в ней будут создаваться новые инстанции бинов-синглтонов. Поэтому depinject-овский
синглтон, не совсем синглтон в классическом понимании. Если бин-контэйнер сделать классическим синглтоном, то все
бины-синглтоны этого контэйнера станут классическими.

### Бин-контэйнер

Бин-контэйнер представляет из себя интерфейс, который должен расширять интерфейс `BeanContainer`. В интерфейсе
`BeanContainer` нет ни каких методов - он служит лишь как индикатор. Самже интерфейс бин-контэйнера должен содержать
методы без параметров. Имена методов значения не имеют. Имеют значения тип возвращаемого значения.

> Тип возвращаемого значения бин-контэйнера должен однозначно определать какой-то один конкретный бин.

Если типу возвращаемого значения соответствует больше одного бина, или не соответствует вообще ни одного, то
происходит ошибка сборки.

Бины к бин-контэйнеру необходимо подключать с помощью аннотации `@Include`.

Бин-контэйнер реализуется автоматически с помощью кодогенерации. Есть метод `DepinjectUtil.implementBeanContainers`
из библиотеки `greetgo.depinject.gen`, который сканирует указанный пакет на наличие интерфейсов бин-контэйнера
и создаёт для каждого найденного интерфейса его реализацию. Потом, эту реализацию, можно инстанциировать
с помощью метода `Depinject.newInstance`.

###### Bean creation variants
### Способы создания бинов

Существует три способа создания бина:

  - Посредством бин-класса (стандартный вариант);
  - Посредством бин-метода;
  - Посредством бин-фабрики.

#### Создание бина посредством бин-класса

Бин-класса - это класс помеченный аннотацией `@Bean`. У бин-класса должен быть конструктор по умолчанию, чтобы
библиотека смогла создать инстанцию этого бина.

#### Создание бина посредством бин-метода

Бин-метод - это публичный метод некого бина, помеченный аннотацией `@Bean`. Объект, возвращаемый этим методом
автоматически становиться бином. Так можно создавать бины без контруктора по умолчанию.

#### Создание бина посредством бин-фабрики

Аннотацией `@Bean` можно пометить интерфейс или абстрактный класс. В этом случае depinject не знает как создавать
такой бин, и ему нужна помощь. Эту помощь ему может предоставить бин-фабрика

Бин-фабрика - это бин, который реализует интерфейс `BeanFactory`, который в себе содержит один метод:

```java
public interface BeanFactory {
  Object createBean(Class<?> beanClass) throws Exception;
}
```

Этот метод служит для создания бинов. Ему передаётся интерфейс или абстрактный класс, помеченный `@Bean`-ом, и то, что
этот метод вернёт становиться бином. Бин-фабрика указывается в аннотации `@BeanConfig`.

Также бин-фабрику можно указать в самом интерфейсе или абстрактном классе в аннотации `@FactoredBy`.

Бин-фабрика, указанная в `@BeanConfig-е` распространяется на все бины, которые относятся к этому бин-конфигу, как по
пути аннотации `@Include` так и по пути аннотации `@BeanScanner`. Следуя по `@Include` могут встретиться внутренние
бин-фабрики,

> внутренние бин-фабрики приоритетнее более общих.

Также, бин-фабрика, определённая аннотацией `@FatoredBy`, более приоритетна чем бин-фабрика,
определённая бин-конфигом.

Если бин-фабрика не определена, но аннотация `@Bean` встретилась у интерфейса или абстрактного класса, то генерируется
ошибка сборки.
